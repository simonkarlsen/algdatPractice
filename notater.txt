________________________________________________________________________________________________________________________

BIG O SHORTHANDS:
----------------------

* Arithmetic operations are constant
* Variable assignment is constant
* Accessing elements in an array (by index) or object (by key) is constant
* In a loop, the complexity is the length of the loop times the complexity of whatever happens inside the loop
-----------------------
________________________________________________________________________________________________________________________

________________________________________________________________________________________________________________________
GRAPHS:
-----------
* A graph G is an ordered pair of a set V of vertices and a set E of edges.
* G = (V, E)

• A set of vertices connected by edges
• Directed or Undirected graphs
    - If edge from X to Y, implies edge from Y to X?

* Vertex: a node, for which can use a label to identify it

* connection between 2 nodes

* Path: a sequence of connected nodes

* Cycle: a path starting and ending on the same node

In a graph, not all nodes are necessarily connected


* Directed graph: Edges are uni-directional or ordered pairs. Points to each other.

    - The internet. Pages that links to each other. The relationship is not necessarily mutual. A page can link to
      multiple other pages.

* Undirected graph: Edges are bi-directional (two-way) or unordered pairs. Does not point to each other.
    - Social network like Facebook. Mutual friendship -- > bi-directional


• Vertices can be object with state
    - Eg, name of station, city, friend, IP address
• “Map” from vertex X (key) to a collection of vertices
  (value) reachable from X
• Note: in this way, do not need objects to explicitly
represent edges
________________________________________________________________________________________________________________________

________________________________________________________________________________________________________________________
STREAMS
------------------

Iterators
...........
• The idea is to make our collections to implement Iterable
interface
• Need to implement an iterator for each collection, which keeps
track of one element at a time
• Java compiler is aware of Iterable, and so can automatically
handle “for(X x : collection){…}”
• ie, do not need to call “hasNext()” and “next()” by yourself
• but only as long as that collection does implement Iterable
• Collection should not be changed (eg, add/remove) while
iterating over them

Lambdas
........
• Anonymous classes work fine, but are tedious to write
• Lambdas: syntax sugar to reduce boilerplate
• Java compiler is aware of the interfaces in
java.util.function.*
Consumer<String> lambda = s -> {/* your code */}
//this is equivalent to previous example

() -> {}
• Left-side: the input parameter name(s), with () if none
• can choose the names you want, but usually a single letter
• Right-side: the instruction to execute. If more than one,
should be in a {} block
• Based on input/output types, the compiler will
automatically create the right class, eg Runnable,
Consumer, Predicate or Function

Iterators + Lambdas
...................
• When a container has an iterator, and once we can write
custom code in lambda expressions, we can introduce
the concept of Stream
• The idea is that we can iterate over all elements in
collection, and easily execute code in sequence on each
of the elements
• This can drastically reduce the amount of code you
write, and easier to understand (once you get familiar
with it)


Stream / Pipeline
.................
• At each pipe, the elements can be transformed and/or blocked
(ie not going to next pipe)
• At the end of the stream, we need a collector, which defines
what to do with elements that arrive at the end of the pipeline

.................................................................
Type of Pipes
...............
• Filter: take as input a Predicate<T>, and based on
that decide if elements propagate to next pipe
• Map: transform input, and also change type, based
on a Function<T,R>
• FlatMap: get a stream from input element, and
flatten it into the current stream (examples later)
• There are more, but these are the main ones we will
see in details

    * Filter:
        (Input: String, output: String)

        “a”
        “foo”
        “hello”  --(String)--> ==(Pipe)== --(String)--> [|Collector|]
        “bar”

        • Example: collection.stream().filter(s -> s.length() > 3)
        • Input/Output: String, does not change
        • Blocked: “a”, “foo”, “bar”
        • Allowed: “hello”
        • Collector will only get “hello”


    * Map:
        (Input: String, output: integer)

        “a”
        “foo”
        “hello”  --(String)--> ==(Pipe)== --(Integer)--> [|Collector|]
        “bar”

        • Example: collection.stream().map(s -> s.length())
        • Input String, Output Integer
        • Note: compiler automatically infer type “Integer” based
          on the type returned by the function “String.length()”
        • Collector will receive: 1, 3, 5, 3


    * FlatMap:
        (Input: List<Integer>, output: integer)

        [1,2]
        [3]     --(List<Integer>)--> ==(Pipe)== --(Integer)--> [|Collector|]
        [4,5,6]

        • Example: collection.stream().flatMap(l -> l.stream())
        • Input List<Integer>, Output Integer
        • On each of the 3 input lists we open a stream, and propagate its
          output, one element at a time
        • Collector will receive: 1, 2, 3, 4, 5, 6 and NOT [1,2], [3], [4,5,6]
        • So the values of the 3 lists are flattened into a single stream of
          integers, including all values in those lists


    * Combining Pipes:
        “a”
        “foo”
        “hello”  --(String)--> ==(Pipe)== --(String)--> ==(Pipe)== --(Integer)--> [|Collector|]
        “bar”

        • Example: .filter(s -> s.length() > 2).map(s -> s.length())
        • “a” is the only blocked element by the filter
        • Collector will receive: 3, 5, 3


    * Collectors:
        • collectToList(): each element that arrives at the end of the
          pipeline will be added to a new List container
        • forEach(Consumer<X> action): for each element that
          arrives at the end of the pipeline, execute the action
          specified by the user, which takes as input type X being
          the output of the last pipe in the pipeline
        • (There are more, but these are the main ones we will see
          in details)
________________________________________________________________________________________________________________________