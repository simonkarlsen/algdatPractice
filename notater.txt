________________________________________________________________________________________________________________________

BIG O SHORTHANDS:
----------------------

* Arithmetic operations are constant
* Variable assignment is constant
* Accessing elements in an array (by index) or object (by key) is constant
* In a loop, the complexity is the length of the loop times the complexity of whatever happens inside the loop

* 1: constant (best you can have)
* log(N): logarithmic very, very efficient
* N: linear (OK for most cases)
* N log(N): linearithmic (OK for most cases)
* N^2: quadratic (bearable, but things start to get
* N^3: cubic (becoming painful)
* 2^n: exponential (completely hopeless , time to cry in a corner)


Big O Rules of Thumb:
â€¢ When you have a polynomial, for upper bound just
  look at the highest exponent
â€¢ ğ‘ğ‘›3+ğ‘ğ‘›2+ğ‘ğ‘›+ğ‘‘ = ğ‘‚(ğ‘›3)
â€¢ This means that, when analyzing an algorithm, you
  can ignore the parts with less impact
â€¢ When representing constants independent from the
  problem size, just use 1 by convention, eg ğ‘‚1


Big â„¦ Lower Bound
â€¢ğ‘“(ğ‘›) = Î©(ğ‘”(ğ‘›))
â€¢In other words, ğ‘”(ğ‘›) is a lower bound
â€¢Useful to consider how expensive algorithm is even
 in the best possible scenario
â€¢ Î©(1) is a trivial lower bound valid for all functions


Big Î˜ Tight Bound
â€¢ ğ‘“(ğ‘›) = Î˜(ğ‘”(n))
â€¢ This happens when the lower and
  upper bounds are asymptotically the same (and just
  differ by the constant)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Bubble Sort:
 â€¢ Easiest sorting algorithms
 â€¢ From left to right
 â€¢ Look at adjacent cards, and swap them if not in
   order
 â€¢ Repeat from left to right till no more swap

 Runtime of Bubble Sort
 â€¢ To sort N cards, need at most N iterations, in which
 you check at most N-1 pairs
 â€¢ Even if already sorted, need to check each of N-1
 pairs at least once, to see if indeed sorted
 â€¢ â„¦(ğ‘) and O(ğ‘^2) pair comparisons
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Insertion Sort
â€¢ An array of size 0 or 1 is
always considered sorted
â€¢ From left to right, till length N
â€¢ K-leftmost values are sorted
â€¢ Position K+1 is not sorted,
insert it in the first K
â€¢ by swapping adjacent elements,
  like in Bubble Sort
â€¢ Best case: already sorted, eg. 1-2-3-4-5-6. Need to do N-1 comparisons, so â„¦(N)
â€¢ Worst case: opposite order, e.g. 6-5-4-3-2-1. Each element needs to be compared and
  swapped with all previous K ones, so O(N^2)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Recursion:

Recursion in computer science is a method
of solving a problem where the solution
depends on solutions to smaller instances
of the same problem (as opposed to
iteration)â€¦ Most computer programming
languages support recursion by allowing a
function to call itself from within its own
code.
You need a way to stop it(reduce input and stop condition), otherwise it will go on forever (stack overflow)

Recursion vs. Iterative
â€¢ Iterative versions of algorithms are â€œusuallyâ€ better
â€¢ recall that each recursive call has to create and push a new function call
frame
â€¢ However, there are many algorithms that are easier and
more efficient to write in a recursive form
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Merge Sort:
â€¢ Divide and Conquer
â€¢ Recursive implementation
â€¢ Split the array in two
â€¢ Sort the two parts
â€¢ Merge the two parts once sorted


Merge of Halves
â€¢ By recursion, I can sort the 2 halves, but array with 2 sorted halves is not sorted
â€¢ Scan the 2 halves, and copy min to a new array
â€¢ Between N/2 and N comparisons: once reached end of one half, copy over the other

Cost
â€¢ Cost based on 2 recursive calls and then merge
â€¢ C(1) = O(1)
â€¢ C(n) >= C(n/2) + C(n/2) + n/2
â€¢ Best case for merge, only have to look at one of the halves
â€¢ Eg, all elements in half A are lower than first element in half B
â€¢ C(n) <= C(n/2) + C(n/2) + n
â€¢ Worst case for merge, need to look at whole of both halves
â€¢ â€¦ ğ¶ ğ‘› = Î˜(ğ‘› log ğ‘›)

Considerations
â€¢ Asymptotically, does not exist comparison-based
sorting better than O(n log n)
â€¢ Merge-sort is therefore asymptotically optimal
â€¢ Ie, no instance for which get worse than O(n log n)
â€¢ Butâ€¦ more memory, need extra array buffer
â€¢ â€¦ might be not best on average
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Quick Sort:
â€¢ Most used sorting algorithm
â€¢ Ie, usually it is the default in the language APIs
â€¢ Fast on average, usually â€œn log nâ€
â€¢ Better â€œconstantâ€ compared to Merge Sort (eg, no moving data
to buffer)
â€¢ But can go till ğ‘›^2 in worst case
â€¢ Minimal memory overhead
â€¢ Lot of variants studied during the years

â€¢ Still Divide and Conquer algorithm, like Merge Sort
â€¢ Choose a value X (pivot)
â€¢ Move values <X before X, and >X after it
â€¢ After one step X is in the correct position
â€¢ Apply recursion on subarrays before and after X

Choice of Pivot
â€¢ Choice of pivot is crucial for
performance of Quick Sort
â€¢ pivot = array[i]
â€¢ For performance, would like a
pivot value that gives the 2
partitions of equal size
â€¢ How to choose â€œiâ€?
â€¢ An option is to take â€œiâ€ at random
â€¢ Another option is to take middle, which is
good when array nearly sorted

Which Sorting Algorithm to
Use?:
â€¢ Unless you have very specific, advanced cases,
you use the default of what is given by the standard
library of the language/framework you use
â€¢ Most of the time, it will be a variant of Quick Sort
â€¢ Fast on average, often â€œn log nâ€ cost, no extra memory
-----------------------



________________________________________________________________________________________________________________________
Test Driven Development (TDD):
â€¢ Bugs in the field can be extremely expensive
â€¢ Ariane 5 explosion, Toyota braking system (100k recalled cars), etc
â€¢ Aim at improving quality (â€œtestingâ€) within acceptable
cost
â€¢ Lot of hype on TDD as possible solution

Some Facts on TDD:
â€¢ There isnâ€™t much scientific evidence that it helps on
large scale systems
â€¢ Small improvements in quality, but also small decrease in
productivity
â€¢ But many anecdotal, success stories
â€¢ TDD can be useful, especially for students / junior developers
â€¢ As any technique, its success depends on the context
    - eg, type of software, stage in which TDD is introduced (at the beginning or in a
      mature project), etc
â€¢ Can test software even without TDD
â€¢ Success of TDD depends also on management


________________________________________________________________________________________________________________________
GRAPHS:
-----------
* A graph G is an ordered pair of a set V of vertices and a set E of edges.
* G = (V, E)

â€¢ A set of vertices connected by edges
â€¢ Directed or Undirected graphs
    - If edge from X to Y, implies edge from Y to X?

* Vertex: a node, for which can use a label to identify its connection between 2 nodes

* Path: a sequence of connected nodes

* Cycle: a path starting and ending on the same node

In a graph, not all nodes are necessarily connected


* Directed graph: Edges are uni-directional or ordered pairs. Points to each other.

    - The internet. Pages that links to each other. The relationship is not necessarily mutual. A page can link to
      multiple other pages.

* Undirected graph: Edges are bi-directional (two-way) or unordered pairs. Does not point to each other.
    - Social network like Facebook. Mutual friendship -- > bi-directional


â€¢ Vertices can be object with state
    - Eg, name of station, city, friend, IP address
â€¢ â€œMapâ€ from vertex X (key) to a collection of vertices
  (value) reachable from X
â€¢ Note: in this way, do not need objects to explicitly
represent edges
________________________________________________________________________________________________________________________

________________________________________________________________________________________________________________________
STREAMS
------------------

Iterators
...........
â€¢ The idea is to make our collections to implement Iterable
interface
â€¢ Need to implement an iterator for each collection, which keeps
track of one element at a time
â€¢ Java compiler is aware of Iterable, and so can automatically
handle â€œfor(X x : collection){â€¦}â€
â€¢ ie, do not need to call â€œhasNext()â€ and â€œnext()â€ by yourself
â€¢ but only as long as that collection does implement Iterable
â€¢ Collection should not be changed (eg, add/remove) while
iterating over them

Lambdas
........
â€¢ Anonymous classes work fine, but are tedious to write
â€¢ Lambdas: syntax sugar to reduce boilerplate
â€¢ Java compiler is aware of the interfaces in
java.util.function.*
Consumer<String> lambda = s -> {/* your code */}
//this is equivalent to previous example

() -> {}
â€¢ Left-side: the input parameter name(s), with () if none
â€¢ can choose the names you want, but usually a single letter
â€¢ Right-side: the instruction to execute. If more than one,
should be in a {} block
â€¢ Based on input/output types, the compiler will
automatically create the right class, eg Runnable,
Consumer, Predicate or Function

Iterators + Lambdas
...................
â€¢ When a container has an iterator, and once we can write
custom code in lambda expressions, we can introduce
the concept of Stream
â€¢ The idea is that we can iterate over all elements in
collection, and easily execute code in sequence on each
of the elements
â€¢ This can drastically reduce the amount of code you
write, and easier to understand (once you get familiar
with it)


Stream / Pipeline
.................
â€¢ At each pipe, the elements can be transformed and/or blocked
(ie not going to next pipe)
â€¢ At the end of the stream, we need a collector, which defines
what to do with elements that arrive at the end of the pipeline

.................................................................
Type of Pipes
...............
â€¢ Filter: take as input a Predicate<T>, and based on
that decide if elements propagate to next pipe
â€¢ Map: transform input, and also change type, based
on a Function<T,R>
â€¢ FlatMap: get a stream from input element, and
flatten it into the current stream (examples later)
â€¢ There are more, but these are the main ones we will
see in details

    * Filter:
        (Input: String, output: String)

        â€œaâ€
        â€œfooâ€
        â€œhelloâ€  --(String)--> ==(Pipe)== --(String)--> [|Collector|]
        â€œbarâ€

        â€¢ Example: collection.stream().filter(s -> s.length() > 3)
        â€¢ Input/Output: String, does not change
        â€¢ Blocked: â€œaâ€, â€œfooâ€, â€œbarâ€
        â€¢ Allowed: â€œhelloâ€
        â€¢ Collector will only get â€œhelloâ€


    * Map:
        (Input: String, output: integer)

        â€œaâ€
        â€œfooâ€
        â€œhelloâ€  --(String)--> ==(Pipe)== --(Integer)--> [|Collector|]
        â€œbarâ€

        â€¢ Example: collection.stream().map(s -> s.length())
        â€¢ Input String, Output Integer
        â€¢ Note: compiler automatically infer type â€œIntegerâ€ based
          on the type returned by the function â€œString.length()â€
        â€¢ Collector will receive: 1, 3, 5, 3


    * FlatMap:
        (Input: List<Integer>, output: integer)

        [1,2]
        [3]     --(List<Integer>)--> ==(Pipe)== --(Integer)--> [|Collector|]
        [4,5,6]

        â€¢ Example: collection.stream().flatMap(l -> l.stream())
        â€¢ Input List<Integer>, Output Integer
        â€¢ On each of the 3 input lists we open a stream, and propagate its
          output, one element at a time
        â€¢ Collector will receive: 1, 2, 3, 4, 5, 6 and NOT [1,2], [3], [4,5,6]
        â€¢ So the values of the 3 lists are flattened into a single stream of
          integers, including all values in those lists


    * Combining Pipes:
        â€œaâ€
        â€œfooâ€
        â€œhelloâ€  --(String)--> ==(Pipe)== --(String)--> ==(Pipe)== --(Integer)--> [|Collector|]
        â€œbarâ€

        â€¢ Example: .filter(s -> s.length() > 2).map(s -> s.length())
        â€¢ â€œaâ€ is the only blocked element by the filter
        â€¢ Collector will receive: 3, 5, 3


    * Collectors:
        â€¢ collectToList(): each element that arrives at the end of the
          pipeline will be added to a new List container
        â€¢ forEach(Consumer<X> action): for each element that
          arrives at the end of the pipeline, execute the action
          specified by the user, which takes as input type X being
          the output of the last pipe in the pipeline
        â€¢ (There are more, but these are the main ones we will see
          in details)
________________________________________________________________________________________________________________________