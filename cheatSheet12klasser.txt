BubbleSort():
---------------
- public class ... implements ...
    - public <T extends ...... void sort(T[] array)
        - Return hvis array er null
        - boolean swapped er lik true
        - while (swapped)
            - swapped = false;
            - For-loop med i < array.length - 1
                - int j = i + 1 inne i loopen
                -  if(array[i].compareTo(array[j]) > 0 ){
                    - T tmp er lik array[i]
                    - array[i] er lik array[j];
                    - array[j] er lik tmp;
                    - swapped = true;

---------------
InsertionSort():
---------------
- public class ... implements ...
    - @Override
    - public <T extends ...... void sort(T[] array)
        - Return hvis array er null {}
        - Vanlig for-loop
        - for (int j = i - 1; j > 0; j--) {
        --> - if (array[j].compareTo(array[j + 1]) > 0) {
            --> - T tmp er lik array[j + 1];
                - array[j + 1] er lik array[j];
                - array[j] er lik tmp
            -else
                --> break;


---------------
QuickSort():
---------------
- public class ... implements ...
- @Override
- public <T extends ...... void sort(T[] array)
    - Return hvis array er null {}
    - quickSort(0, array.length - 1, array);

- private T<extends osv.. quickSort(int low, int high, T[] array)
--> - int i = low
    - int j = high
    - T pivot = array[low + (high-low) / 2];

        - while(i <= j)
        --> - while array[i].compareTo(pivot) < 0
            --> - i++;

            - while array[j].compareTo(pivot) > 0
            --> - j--;

            - if(i <= j)
            --> - T tmp = array[i];
                - array[i] = array[j];
                - array[j] = tmp;
                - i++;
                - j--;

        (ifs under er utenfor fÃ¸rste while!)
        - if(j > low)
            --> quickSort(j, low, array);

        - if(i < high)
            --> quickSort(j)


---------------
MergeSort():
---------------
- public class ... implements ...
    -- @Override
    - public <T extends ...... void sort(T[] array)
    - Return hvis array er null {}
    - T[] buffer = (T[])  new Comparable[array.length];
    - mergeSort (0, array.length - 1, array, buffer);

- private <T extends Comparable <T>> mergeSort (int low, int high, T[] array, T[] buffer) {
    - if (low >= high), return
    - int middle = low + (high - low) / 2;
    - mergeSort(low, middle, array, buffer);
    - mergeSort(middle + 1, high, array, buffer);
    - merge(low, middle, high, array, buffer);

- private <T extends Comparable <T>> void merge(int low, int high, int middle, T[] array, T[] buffer) {
    - for (int i = low; i <= high; i++)
        --> buffer[i] = array[i];

    - int i = low;
    - int j = middle + 1;

    -  for (int k = low; k <= high; k++) {
        * if(i > middle) {
            --> array[k] = buffer[j++];

        * else if (j > high) {
            --> array[k] = buffer[i++];

        * else if (buffer[j].compareTo(buffer[i]) < 0) {
            --> array[k] = buffer[j++];

        * else {
            --> array[k] = buffer[i++];



-------------------------
 MyHashMapWithLists<K, V>
-------------------------

public class MyHashMapWithLists<K, V> implements MyHashMap<K, V> {
    private final int M = 997; //prime number

    private class Entry {
        K key;
        V value;

        public Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private List<Entry>[] data = new ArrayList[M];

    @Override
        public void put(K key, V value) {
            int i = index(key);
            if(data[i] == null) {
                data[i] = new ArrayList<>();
            }

            List<Entry> list = data[i];

            for(int j = 0; j < list.size(); j++) {
                Entry entry = list.get(j);
                if(key.equals(entry.key)) {
                    entry.value = value;
                    return;
                }
            }
            list.add(new Entry(key, value));
        }

        private int index(K key) {
            int positiveHash = key.hashCode() & 0x7f_ff_ff_ff; //need to have this mask in order to get a positive hash! A negative number would be bad!
                return positiveHash % M;
        }


    *  @Override
          public void delete(K key) {
          //samme som put(), bare at:
            if(data[i] == null){
                return;
            }
          }

           //, at:
            if(key.equals(entry.key)){
                list.remove(j);
                return;
            }

            // - returnerer ikke noe utenfor for-loopen


      *  @Override
              public V get(K key) {
              //samme som delete(), bare at:
                if(data[i] == null){
                    return null;
                }
              }

               //, at:
                if(key.equals(entry.key)){
                    return entry.value;
                }

                * return null utenfor for-loopen

      *     @Override
            public int size() {
                int size = 0;
                for(int i=0; i<data.length; i++){
                    if(data[i] != null){
                        size += data[i].size();
                    }
                }
                return size;
            }
        }